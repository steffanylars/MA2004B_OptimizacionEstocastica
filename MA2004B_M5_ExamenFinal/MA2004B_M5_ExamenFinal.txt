
'''
    Steffany Mishell Lara Muy
    A00838589
    Optimización Estocástica
    Codigo de examen final - Algoritmo de Montecarlo
'''
# Importar Librerías
import streamlit as st
import random
import math
import pandas

# Comienza el código
class Montecarlo():
    def __init__(self, n_experimentos, a, b, usar_infinito=False):
        '''
            Esta función inicializa los valores necesarios para la simulación de Montecarlo dentro de la función. Así todas las definiciones tienen acceso a ella.
            También crea las listas necesarias para almacenar los valores aleatorios, las alturas y las áreas.
        '''
        self.n_experimentos = n_experimentos
        self.a = a
        self.b = b
        self.usar_infinito = usar_infinito
        self.valores_aleatorios = []
        self.valores_transformados = []
        self.alturas = []
        self.areas = []
        self.integral_estimacion = 0
        
        if self.usar_infinito:
            self.generar_valores_infinito()
        else:
            self.generar_valores_aleatorios()
        
        self.calcular_integral()

    def f(self, x):
        '''
            Función a integrar: (2/π) * 1/(e^x + e^-x)
            Con protección contra overflow
        '''
        if abs(x) > 700:
            return 0.0
        if abs(x) > 20:
            return (2 / math.pi) * math.exp(-abs(x))
        else:
            return (2 / math.pi) * (1 / (math.exp(x) + math.exp(-x)))

    def generar_valores_aleatorios(self):
        '''
            Genera n valores aleatorios en el rango [a, b] y calcula las alturas f(x) correspondientes.
        '''
        for i in range(self.n_experimentos):
            x = random.uniform(self.a, self.b)
            y = self.f(x)
            self.valores_aleatorios.append(x)
            self.alturas.append(y)
            self.areas.append((self.b - self.a) * y)

    def generar_valores_infinito(self):
        '''
            Genera valores para el rango (-inf, inf) usando cambio de variable.
            t in (0,1) -> x = tan(pi*(t-0.5)) in (-inf, inf)
        '''
        for i in range(self.n_experimentos):
            t = random.uniform(0.001, 0.999)
            angulo = math.pi * (t - 0.5)
            x = math.tan(angulo)
            jacobiano = math.pi / (math.cos(angulo) ** 2)
            y = self.f(x)
            contribucion = y * jacobiano
            
            self.valores_aleatorios.append(t)
            self.valores_transformados.append(x)
            self.alturas.append(y)
            self.areas.append(contribucion)

    def calcular_integral(self):
        '''
            Calcula la estimación de la integral usando Montecarlo:
            Integral ≈ (b-a)/n * Σf(xi)
        '''
        if self.usar_infinito:
            self.integral_estimacion = sum(self.areas) / self.n_experimentos
        else:
            suma_alturas = sum(self.alturas)
            self.integral_estimacion = ((self.b - self.a) / self.n_experimentos) * suma_alturas

    def resultados(self):
        '''
        Muestra los resultados obtenidos: 
            valores aleatorios generados
            las alturas
            las áreas 
            estimación en la integral.
        '''
        if self.usar_infinito:
            df = pandas.DataFrame({
                't (Uniforme 0-1)': self.valores_aleatorios,
                'x (Transformado)': self.valores_transformados,
                'Alturas (f(x))': self.alturas,
                'Áreas': self.areas
            })
        else:
            df = pandas.DataFrame({
                'Valores Aleatorios (x)': self.valores_aleatorios,
                'Alturas (f(x))': self.alturas,
                'Áreas': self.areas
            })
        return df, self.integral_estimacion

# ------------------------------------------------------------------Interfaz gráfica
st.title("Algoritmo de Montecarlo")
st.write("### Por: Steffany Mishell Lara Muy (A00838589)")
st.write("---")
st.write("La función seleccionada fue f(x) = 1 / (e^x + e^-x). Se utilizará el método de Montecarlo para estimar la integral definida de esta función en un rango [a, b] especificado por el usuario. La integral es  en el rango [1,b] de 2/pi * f(x) dx.")

st.write("#### Parámetros de la simulación: ")

n = st.number_input(
    "Número de simulaciones (n):",
    min_value=1,
    value=100,
    step=1
)

st.write("Rango de la integral [a,b]")

usar_infinito = st.checkbox("Usar rango infinito (-Inf, Inf)")

if usar_infinito:
    a, b = None, None
    enviar = st.button("Ejecutar Simulación")
    
    if enviar:
        st.write("### Resultados de la Simulación:")
        simulacion = Montecarlo(n_experimentos=n, a=a, b=b, usar_infinito=True)
        tablita, estimacion_integral = simulacion.resultados()
        tablita.index += 1
        st.write(f"### Estimación de la integral: {round(estimacion_integral, 6)}")
        st.write("---")
        st.write("### Tabla de valores generados:")
        st.dataframe(tablita)
else:
    col1, col2 = st.columns(2)
    with col1:
        a = st.number_input(
            "a:",
            value=-6,
            step=1
        )
    with col2:
        b = st.number_input(
            "b:",
            value=6,
            step=1
        )

    # Validación de que b > a
    if b <= a:
        st.error("Error: b debe ser mayor que a")
    else:
        enviar = st.button("Ejecutar Simulación")
        
        if enviar:
            st.write("### Resultados de la Simulación:")
            simulacion = Montecarlo(n_experimentos=n, a=a, b=b, usar_infinito=False)
            tablita, estimacion_integral = simulacion.resultados()
            tablita.index += 1
            st.write(f"### Estimación de la integral: {round(estimacion_integral, 6)}")
            st.write("---")
            st.write("### Tabla de valores generados:")
            st.dataframe(tablita)